options {
  STATIC=false;
  JDK_VERSION="1.8";
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
}


PARSER_BEGIN(DmParser)
package com.example.kotlinspringboot.parser.simple;

import java.io.*;
import java.util.*;
import static com.example.kotlinspringboot.parser.simple.DmParserBaseKt.preHandling;

public class DmParser extends DmParserBase {

    public static String simple(String inString) {
        DmParser parser = new DmParser(new StringReader(preHandling(inString)));
        try{
            return parser.simple();
        } catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    private List<List<String>> negativeStrings = new ArrayList<>();

    public static String complex(String inString) {
        DmParser parser = new DmParser(new StringReader(preHandling(inString)));
        try{
            return parser.complex();
        } catch (Exception e){
            throw new RuntimeException(e);
        }
    }
}

PARSER_END(DmParser)


TOKEN : {
    < PHASE: <LETTER> (<LETTER>)*  >
|   < OPEN_BRACE: "{" (" ")* >
|   < CLOSE_BRACE: (" ")* "}" >
|   < OR: (" ")* "|" (" ")* >
|   < AND: (" ")+ >
|   < FALSE_FUNCTION: "%false%" >
|   < CONCAT_FUNCTION: ("%any%" | "%precededBy%") (<REPEAT>)?  >
|   < REPEAT: "[" (<LETTER>)+ "]" >
|   < #LETTER: ~[ "{", "}", "|", " ", "%", "[", "]"] >
}


SKIP : {
    < COMMENTS: "%!--" (~[])* "--%" >
}

String complex():
{
    List<String> parts;
}
{
    parts = outParts()
    { return handleParts(parts, negativeStrings); }
}


List<String> outParts() :
{
    List<String> partStrings = new ArrayList<>();
    String partString;
}
{
     partString = getPartOrFunction()
     { partStrings.add(partString); }
     (
        <AND>
        partString = getPartOrFunction()
        { partStrings.add(partString); }
     )*

    { return partStrings; }
}

String getPartOrFunction():
{
    String s;
}
{
    (s = function() | s = simple())
    {
       System.out.println(s);
       return s;
    }
}


String function() :
{
    Token function;
}
{
    function = <CONCAT_FUNCTION>
    { return function.image; }
}

String simple() :
{
    List<String> parts;
}
{
    parts = expr()
    {
        return getPartString(parts);
    }
}


List<String> expr():
{
    List<String> leftTerm;
    List<String> rightTerm;
    Token concatToken = null;
}
{
    leftTerm = wordsOrGroup()
    (
        LOOKAHEAD(2)
        [concatToken = <AND>]
        rightTerm = wordsOrGroup()
        {
            leftTerm = getCombinationsOfTwoList(leftTerm, rightTerm, concatToken);
        }
    )*

    {
        return leftTerm;
    }

}

List<String> wordsOrGroup():
{
    List<String> leftPhase;
    List<String> rightPhase;
}
{
    leftPhase = phaseOrGroup()
    (
        <OR>
        rightPhase = phaseOrGroup()
        { leftPhase = mergeToLeft(leftPhase, rightPhase); }
    )*

    { return leftPhase; }

}

List<String> phaseOrGroup() :
{
    Token token;
    Token repeat = null;
    Token falseFunction = null;
    List<String> expr;
}
{
    token = <PHASE> [ repeat = <REPEAT>] [ falseFunction = <FALSE_FUNCTION> ]
    {
        return singleElementList(token.image, repeat, falseFunction, negativeStrings);
    }
|
    (
        <OPEN_BRACE> expr = expr() <CLOSE_BRACE> [ repeat = <REPEAT> ] [ falseFunction = <FALSE_FUNCTION> ]
        {
            return groupConsiderRepeat(expr, repeat, falseFunction, negativeStrings);
        }
    )

}
